<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">

    <title>Game of Life Tutorial | Spicy Yoghurt</title>
    <meta name="description" content="Game of Life tutorial by Spicy Yoghurt">
    <meta name="author" content="Spicy Yoghurt">
</head>

<body>
<canvas id="canvas" width="1500" height="700" style="border:1px solid lightgrey;">
    Your browser does not support the HTML5 canvas tag.
</canvas>
<script>
    var canvasWidth = 1500; // don't change these
    var canvasHeight = 700; // don't change these
    var scale = 5; // change this to change the size of the cells
    var speed = 80; // change this to change the speed of the simulation
    var type = 'cell based'; // this defines the method used for next generation 
    // (smooth vanilla, smooth vanilla stable, cell based, sigmoid, relu)
    var numbersOfGrey = 10; // this defines number of colors used for printing the cell

    class Cell {
        static width = scale;
        static height = scale;

        constructor(context, gridX, gridY) {
            this.context = context;

            // Store the position of this cell in the grid
            this.gridX = gridX;
            this.gridY = gridY;

            // Make random cells alive
            this.alive = Math.random();
        }

        draw() {
            // Draw a simple square
            const aliveScaled = Math.floor(this.alive * (numbersOfGrey + 1)) / numbersOfGrey;
            this.context.fillStyle = `rgb(${255 * (1 - aliveScaled)}, ${255 * (1 - aliveScaled)}, ${255 * (1 - aliveScaled)})`;
            this.context.fillRect(this.gridX * Cell.width, this.gridY * Cell.height, Cell.width, Cell.height);
        }
    }

    class GameWorld {

        static numColumns = canvasWidth / scale;
        static numRows = canvasHeight / scale;

        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.context = this.canvas.getContext('2d');
            this.gameObjects = [];

            this.createGrid();

            // Request an animation frame for the first time
            // The gameLoop() function will be called as a callback of this request
            window.requestAnimationFrame(() => this.gameLoop());
        }

        createGrid() {
            for (let y = 0; y < GameWorld.numRows; y++) {
                for (let x = 0; x < GameWorld.numColumns; x++) {
                    this.gameObjects.push(new Cell(this.context, x, y));
                }
            }
        }

        isAlive(x, y) {
            if (x < 0 || x >= GameWorld.numColumns || y < 0 || y >= GameWorld.numRows) {
                return 0;
            }

            return this.gameObjects[this.gridToIndex(x, y)].alive;
        }

        gridToIndex(x, y) {
            return x + (y * GameWorld.numColumns);
        }

        checkSurrounding() {
            const sigmoid = (numAlive) => {
                const a = 4;
                const k = 1.1;
                return 1 / (1 + Math.exp(-(numAlive - a) / k));
            };

            const relu = (numAlive) => {
                const c = .3;
                const k = 5;
                return Math.min(Math.max(0, numAlive / k - c), 1);
            };

            const smoothVanilla = (numAlive) => {
                const nothingStart = 1.1; // higher makes less cells alive
                const mid = 2; // lower makes more cells alive
                const aliveStop = 2.74; // higher makes more cells alive
                const killFactor = 50; // higher is more aggressive, more cells will die

                if (numAlive >= nothingStart && numAlive <= mid) {
                    return numAlive / 8;
                } else if (numAlive >= mid && numAlive <= aliveStop) {
                    return numAlive / (2 * (aliveStop - mid)) + 1 - aliveStop / (2 * (aliveStop - mid));
                } else {
                    return numAlive / killFactor;
                }
            };

            const smoothVanillaStable = (numAlive, alive) => {
                const nothingStart = 1.5; // higher makes less cells alive
                const mid = 2.2; // lower makes more cells alive
                const aliveStop = 3.5; // higher makes more cells alive
                const killFactor = 150; // higher is more aggressive, more cells will die

                if (numAlive >= nothingStart && numAlive <= mid) {
                    return alive;
                } else if (numAlive >= mid && numAlive <= aliveStop) {
                    return numAlive / (2 * (aliveStop - mid)) + 1 - aliveStop / (2 * (aliveStop - mid));
                } else {
                    return numAlive / killFactor;
                }
            };
            
            const cellBased = (numAlive, alive) => {
                const a = 1.4;
                const b = 2;
                const c = 3;
                const killFactor = 90;
                
                if (numAlive >= a && numAlive <= b) {
                    return alive;
                } else if (numAlive >= b && numAlive <= c) {
                    return (alive + 1) / 2;
                } else {
                    return numAlive / killFactor;
                }
            };
            // Loop over all cells
            for (let x = 0; x < GameWorld.numColumns; x++) {
                for (let y = 0; y < GameWorld.numRows; y++) {

                    // Count the nearby population
                    let numAlive =
                        this.isAlive(x - 1, y - 1)
                        + this.isAlive(x, y - 1)
                        + this.isAlive(x + 1, y - 1)
                        + this.isAlive(x - 1, y)
                        + this.isAlive(x + 1, y)
                        + this.isAlive(x - 1, y + 1)
                        + this.isAlive(x, y + 1)
                        + this.isAlive(x + 1, y + 1);
                    let centerIndex = this.gridToIndex(x, y);
                    const alive = this.gameObjects[centerIndex].alive;
                    
                    switch (type) {
                        case 'sigmoid':
                            this.gameObjects[centerIndex].nextAlive = sigmoid(numAlive);
                            break;
                        case 'relu':
                            this.gameObjects[centerIndex].nextAlive = relu(numAlive);
                            break;
                        case 'smooth vanilla':
                            this.gameObjects[centerIndex].nextAlive = smoothVanilla(numAlive);
                            break;
                        case 'smooth vanilla stable':
                            this.gameObjects[centerIndex].nextAlive = smoothVanillaStable(numAlive, alive);
                            break;
                        case 'cell based':
                            this.gameObjects[centerIndex].nextAlive = cellBased(numAlive, alive);
                            break;
                    }
                }
            }

            // Apply the new state to the cells
            for (let i = 0; i < this.gameObjects.length; i++) {
                this.gameObjects[i].alive = this.gameObjects[i].nextAlive;
            }
        }

        gameLoop() {
            // Check the surrounding of each cell
            this.checkSurrounding();

            // Clear the screen
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Draw all the gameobjects
            for (let i = 0; i < this.gameObjects.length; i++) {
                this.gameObjects[i].draw();
            }

            // The loop function has reached it's end, keep requesting new frames
            setTimeout(() => {
                window.requestAnimationFrame(() => this.gameLoop());
            }, speed)
        }
    }

    window.onload = () => {
        // The page has loaded, start the game
        let gameWorld = new GameWorld('canvas');
    }

</script>
</body>

</html>
